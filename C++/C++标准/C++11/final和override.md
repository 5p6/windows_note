C++ 借由虚函数实现运⾏时多态，但 C++ 的虚函数⼜很多脆弱的地⽅：
* 无法禁止子类重写它。可能到某⼀层级时，我们不希望子类继续来写当前虚函数了。
* 容易不小心隐藏⽗类的虚函数。⽐如在重写写时，不小心声明了⼀个签名不⼀致(比如加了`const`标签)但有同样名称的新函数。

C++11 提供了 final 来禁⽌虚函数被᯿写/禁⽌类被继承， override 来显示地᯿写虚函数。 这样编译器给我们不小心的⾏为提供更多有⽤的错误和警告。常用场景
```C++
struct Base1 final { }; // final 在类上不让继承
struct Derived1 : Base1 {}; // 编译错：Base1不允许被继承

// ------------------
struct Base2 {
 virtual void f1() final;
 virtual void f2();
};
struct Derived2 : Base2 {
 virtual void f1(); // 编译错：f1不允许᯿写
 virtual void f2(int) override; // 编译错：⽗类中没有 void f2(int)
};
```

对于该关键字,建议如下:
* 在处理`final`时应该慎之又慎，需要case by case地处理。
* 至于`override`，无论哪里用到了覆写，直接加上去就完事了，只会有益处而不会有害，不过看清楚你的本意到底是不是覆写哈。尤其是你加上`override`后编译器报错的，一定要先检查你的本意到底是不是覆写，确定你真的犯了错误后，再去修改源代码。
* 加上`override`后，我建议你把子类的`virtual`关键字去掉，并且以后都遵循上边提到的规范：只有顶层的虚函数加上`virtual`，其余子类在覆写时全部用`override`来标记。
* 当你看到一个函数标记了`virtual`时，弄清楚它是不是顶层虚函数其实是一件非常困难的事情，这个时候我建议你多用用你的编译器，当你使用`override`报错时，也有可能它确实就是顶层`virtual`函数了。